Ok, all the environment is now working with Karen set up on Linux, and JVM v 6 up and working!!

Lesson 3:

Now, he tells me they're not going to use Karel throughout the whole class!!! Well, whatever, it was still a worth-while exercise.

Step-wise refinement, decomposition, top-down vs bottom-up design.

	- Takes ~100 hours of programming to start thinking in terms of top-down design principles as opposed to bottom-up ones. Generally, top-down design is preferable, as it builds naturally from abstractions that we (as humans) think in towards instructions that the computer can execute.

	- What an excellent class - my solution to the exercise to fix the city was done using a top-down design process.

	- Good style, in terms of the practice of 'software engineering' is more important than just getting the program working.

How does decomposition work? What are the proper ways to decompose a program?

	- Each 'method' should solve one problem for you.
	- Most methods are ~ 1-15 lines long; a one-line method is likely just re-naming something - helps to think of the method in the correct terms.
	- Use good names.
	- Use good comments, and at least one comment per method.
	- One really good type of comment that was covered without real detail in the lecture is putting pre and post conditions in the comments that are associated with methods. For instance, a 'before' and 'after' condition that relates to when the method was called/executed.

Lesson 5:

Not too much new stuff; covered variables and declaring classes, making objects, passing messages to objects, etc.
The one really new piece of information was about the '%' operator in java, which he called the remainder operator, which makes sense, but then made a very specific point about how it is different than the operation in mathematics known as modulo operator, which I find confusing, because I thought that's precisely what it was...maybe this will be clarified in the future.

Lesson 6:

	- Reading numbers
	- Operators, casting, assignment, shorthand assignment
	- constants identified by "private static final type" (i.e. private static final double)
	- for loops in java and how they operate
	- while loops; remember these were used in Karel

Lesson 7:

	- 'for' vs. 'while' loops - they are (can be) exactly equivalent, so
	why does a programming language give you both forms? 'for' is really there to
	enable you to iterate something a known number of times, while 'while' is
	there to allow you to iterate an 'unknown' number of times.
	- Important to think of methods/functions as 'messages' that are called by
	objects; for instance, player.move(3) should be thought of as the 'player'
	object being passed a 'move(3)' message: basic structure/syntax is
	'receiver.method(argument)'. Alternatively, you are sending a message to an
	object.

	/////////////////////////////////////////////////////////////////////////////
		At this point, it seems like I'm fully done with the Karel program. I'll
		continue to use Eclipse, because it's a full development environment, but I
		also want to begin to incorporate some of the tools available to me in a
		program like 'atom,' and get used to one environment for programming/coding
		that will serve me across the board.
	/////////////////////////////////////////////////////////////////////////////

Lesson 8:

	- Information hiding is one of the key principles of software engineering and
	should be of primary concern to software developers. Lots of different ways
	exist to make toast: heating coils, elves, etc. The user does not, and should
	not care about the 'how'.
	- Any time a method is called, you are given a new stack-frame with a copy of
	the value of the variable that was passed to the method (pass by value). This
	is reminicent of the stacks that I looked at in the assembly language class I
	took a year ago.
	- Local variable's lifetimes are constrained to the length of time the method
	exists (is called/operating). Once it is done, they disappear. Instance
	variables, on the other hand, live for the lifetime of the object, and are
	visible to all the methods within the calling class. Used to store values
	between calls of methods...this is what is known as 'state', or the state of
	the object.
		- Class example of this was using multiple 'water bottles' with soda inside
		and calling multiple methods screwCapOn(), unscrewCap(), etc. In between all
		of the different calls of these functions, the amount of soda in the
		respective bottles did not change - which is what you want, and is the point
		of an instance variable.
		- Question from class was asked regarding what the difference between global
		and instance variables was. Mehran said there is a difference, but they are
		bad style, so they're not covered in the class.
	- Java convention asserts that constants be declared up at the top of a
	class, then all the methods, and then (at the bottom) all of the instance
	variables - which actually do change.
	- Random number generators. Use seeds to test program for bugs...this way
	when you're testing a program, it will have reproducible results.

	- 'Class' variables vs. 'instance' variables: When you define a class variable
	you use the 'static' keyword to do so. When accessing these variables, you can
	either use an actual object (th.x) or the actual class (Thing.x). The
	preferred way of doing this is by way of the 'class' variable, to make it
	explicitly clear that the variable being accessed is a property of the entire
	class, as opposed to a single instance.

Lesson 9: Creating your own classes

	- Constructors can have different sets of parameters...it's how it will know
	which of the constructors to call. They also DO NOT have return types. They
	are called, create an object, and (I think...) return a 'reference/pointer'
	to the object.
	- 'Shadowing/aliasing' happens when a parameter name is the same as an instance
	variable name - it can be corrected, however with the use of the 'this'
	object. For instance, this.counter = counter...which assigns the counter
	parameter to the instance object's instance variable called counter...a better
	way to do it is to use different names for parameters and instance variables.
	- Objects are passed BY REFERENCE!!! Meaning that the WHOLE object is passed.
	This is different from primitive types, which are passed by VALUE.

//JavaDOC//

	- JAVADOC comments begin with /**, and end with */ - have a feeling this will
	be important when documenting your own classes for later on. There are also a
	couple of other important 'tags' that will allow your comments to be transformed
	into html which will generate documentation for your classes.
		A couple of examples: @param, @result, etc.
	- Javadoc makes it nice, because you can look at a webpage vs. scrolling through
	actual program code.
	/**
	 * Sets the number of units earned
	 * @param units The number of units earned.
	 * @return name The string representation of the student's name.
	 */
	 - Notice how the parameters are included within a javadoc style comment.
	 - All classes you write (with the exception of programs) should have a toString()
	 method - because that method is included with all of your classes, since it
	 is part of the most basic 'object' in java...this is called 'overriding', I
	 think.
